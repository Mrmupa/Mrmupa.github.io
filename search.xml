<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java里的多线程]]></title>
    <url>%2F2019%2F07%2F18%2Fjava%E9%87%8C%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[完成高可用、高并发、高性能，多线程值得拥有 多线程创建线程最好少用继承，多用实现 继承Thread类实现步骤 extends Thread类 重写run方法 调用start方法相关代码12345678910111213141516171819package com.mupa.io;public class test extends Thread &#123; @Override public void run() &#123; for(int i=0;i&lt;2000;i++) System.out.println("听歌"); &#125; public static void main(String[] args) &#123; test st = new test(); st.start(); for(int i=0;i&lt;2000;i++) System.out.println("呵呵"); &#125;&#125; 实现Runnable接口推荐的方式，避免单继承的局限性 实现步骤 implements Runnable 实现run方法 创建线程对象并关联 通过线程对象调用start方法 相关代码123456789101112131415161718192021package com.mupa.io;public class test implements Runnable &#123; public static void main(String[] args) &#123;// test sr = new test();// Thread t = new Thread(sr);// t.start(); //匿名调用 new Thread(new test()).start(); for(int i=0;i&lt;2000;i++) System.out.println("呵呵"); &#125; public void run() &#123; for(int i=0;i&lt;2000;i++) System.out.println("听歌"); &#125;&#125; 实现Callable接口JUC并发包相关，供了解 实现步骤 implements Callable 实现call方法 创建执行服务 提交执行 获取结果 关闭服务相关代码12345678910111213141516171819202122232425262728package com.mupa.io;import java.util.concurrent.*;public class test implements Callable&lt;Boolean&gt; &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; test cd1 = new test(); test cd2 = new test(); test cd3 = new test(); ExecutorService ser = Executors.newFixedThreadPool(3); Future&lt;Boolean&gt; result1 = ser.submit(cd1); Future&lt;Boolean&gt; result2 = ser.submit(cd2); Future&lt;Boolean&gt; result3 = ser.submit(cd3); Boolean r1 = result1.get(); Boolean r2 = result2.get(); Boolean r3 = result3.get(); ser.shutdownNow(); &#125; public Boolean call() throws Exception &#123; for(int i=0;i&lt;2000;i++) System.out.println("呵呵"+i); return true; &#125;&#125; 代理开发模式代理更像是控制功能（限制），而装饰则更像是增强功能 静态代理即做的代理我们已经静态写好了，相对动态代理（动态生成） 相关代码12345678910111213141516171819202122232425262728293031323334353637383940public class Proxy &#123; public static void main(String[] args) &#123; new Company(new You()).happyMarry(); &#125;&#125;interface Wedding&#123; void happyMarry();&#125;class You implements Wedding&#123; @Override public void happyMarry() &#123; System.out.println("你终于结婚了"); &#125;&#125;class Company implements Wedding&#123; private Wedding wedding; public Company(Wedding wedding) &#123; this.wedding = wedding; &#125; @Override public void happyMarry() &#123; ready(); wedding.happyMarry(); after(); &#125; private void after() &#123; System.out.println("结婚结束"); &#125; private void ready() &#123; System.out.println("结婚开始"); &#125;&#125; 简化线程Lambda简化线程简化线程（使用一次），接口仅有一个没有实现的方法外部类-&gt;静态内部类-&gt;局部内部类-&gt;匿名内部类-&gt;lambda表达式 相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243public class Lambda &#123; static class Like2 implements ILike&#123; @Override public void lambda() &#123; System.out.println("内部类"); &#125; &#125; public static void main(String[] args) &#123; ILike like=new Like(); like.lambda(); like = new Like2(); like.lambda(); class Like3 implements ILike&#123; @Override public void lambda() &#123; System.out.println("方法内部类"); &#125; &#125; like = new Like3(); like.lambda(); like = new ILike()&#123; public void lambda()&#123; System.out.println("匿名内部类"); &#125; &#125;; like.lambda(); like = ()-&gt;&#123; System.out.println("lambda"); &#125;; like.lambda(); &#125;&#125;interface ILike&#123; void lambda();&#125;class Like implements ILike&#123; @Override public void lambda() &#123; System.out.println("外部类"); &#125;&#125; 线程状态NEW、RUNNABLE（就绪和运行）、BLOCKED、WAITING、TIMED_WAITING、TERMINATED 新生、就绪、运行、阻塞、结束 new一个对象，进入新生状态 1Thread t=new Thread() 调用start方法，进入就绪状态(四种情况进入就绪：start调用、阻塞解除、yield方法、jvm切换线程) 1t.start(); 就绪后根据调度进入运行状态 运行状态后进入阻塞状态：sleep()、wait()、join()、read()、write() 运行状态后进入dead状态：stop()、destroy() 终止线程stop、destroy方法是不安全的，我们在真正停止线程时要么时线程运行结束，要么加入表示，标记先乘梯是否可以运行 yield礼让线程，运行状态转入就绪状态，而不是阻塞，不是每次都能礼让成功 join合并线程，事实上是插队，其他线程阻塞 优先级优先级只代表被调用的概率，并非绝对优先 守护进程t.setDaemon(true)设置为守护进程 一些方法Thread.currentThread()当前线程Thread.currentThread().isAlive();线程是否还活着Thread.getname和setname处理代理名称 线程同步–并发控制同一个对象多个线程同时操作常见不同步： 3个人一起抢票。由于线程调用等待，导致票数为负数 3个人抢票，在工作空间内都存有需要的数据，然而与主存之间交互不及时，导致取了同一张票 锁synchronized用于控制方法和块，可能会影响效率（同时会影响优先级）要兼得线程安全和性能，就要合理的锁，不能太大，也不能范围太小 synchronied方法 synchronied块 多用synchronied块，最小范围锁List可以直接用并发容器java.util.concurrent.CopyonWriteArrayList 死锁过多的同步可能造成互不释放资源的情况不要在同一个代码块中，持有多个资源的锁（不要锁套着锁） 线程协作线程通信两种方法解决线程通信问题： 管程法 信号灯法生产者消费者模式一种模型，和前面的设计模式不是一个东西 pv:page view 每一个页面的访问量 uv:unique view 用户访问量 vv:visit view 一天看了几次 应用层-&gt;服务层-&gt;数据层生产者消费者事实上就是在应用层和服务层间解耦 管程法有wait和notify方法 相关代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class CoTest01 &#123; public static void main(String[] args) &#123; SynContainer container=new SynContainer(); new Productor(container).start(); new Consumer(container).start(); &#125;&#125;//生产者class Productor extends Thread&#123; SynContainer container; public Productor(SynContainer container) &#123; this.container = container; &#125; public void run() &#123; //生产 for(int i=0;i&lt;100;i++)&#123; System.out.println("生产——&gt;"+i+"个馒头"); container.push(new Steamedbun(i)); &#125; &#125;&#125;//消费者class Consumer extends Thread&#123; SynContainer container; public Consumer(SynContainer container) &#123; this.container = container; &#125; public void run() &#123; //消费 for(int i=0;i&lt;1000;i++)&#123; System.out.println("消费——&gt;"+container.pop().id+"个馒头"); &#125; &#125;&#125;//缓冲区class SynContainer&#123; Steamedbun[] buns = new Steamedbun[10]; int count = 0; public synchronized void push(Steamedbun bun)&#123; if(count == buns.length)&#123; try&#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; buns[count]=bun; count++; this.notifyAll(); &#125; public synchronized Steamedbun pop()&#123; if(count == 0)&#123; try &#123; this.wait();//生产者消费通知消费 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; count--; Steamedbun bun = buns[count]; this.notifyAll(); return bun; &#125;&#125;//馒头class Steamedbun&#123; int id; public Steamedbun(int id) &#123; this.id = id; &#125;&#125; 信号灯法相关代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class CoTest02 &#123; public static void main(String[] args) &#123; Tv tv = new Tv(); new Player(tv).start(); new Watcher(tv).start(); &#125;&#125;class Player extends Thread&#123; Tv tv; public Player(Tv tv) &#123; this.tv = tv; &#125; @Override public void run() &#123; for(int i=0;i&lt;20;i++)&#123; if(i%2==0)&#123; this.tv.play("奇葩说"); &#125;else&#123; this.tv.play("太污了"); &#125; &#125; &#125;&#125;class Watcher extends Thread&#123; Tv tv; public Watcher(Tv tv) &#123; this.tv = tv; &#125; @Override public void run() &#123; for(int i=0;i&lt;20;i++)&#123; tv.watch(); &#125; &#125;&#125;class Tv&#123; String voice; //真表示表演，观众等待 boolean flag=true; public synchronized void play(String voice)&#123; if(!flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("表演了"+voice); this.voice=voice; this.notify(); this.flag=!this.flag; &#125; public synchronized void watch()&#123; if(flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.notify(); this.flag=!this.flag; System.out.println("听到了："+voice); &#125;&#125; 高级主题任务定时调度通过java.util.Timer和java.util.TimerTask来实现定时启动某个线程 相关代码12345678910111213141516171819202122232425import javax.xml.crypto.Data;import java.util.*;public class MyTimer &#123; public static void main(String[] args) &#123; Timer timer =new Timer();// timer.schedule(new MyTask(),1000);// timer.schedule(new MyTask(),1000,200); Calendar cal1 = new GregorianCalendar(); Calendar cal =new GregorianCalendar(2019,6,16,14,55,0); System.out.println(cal1.getTime()); timer.schedule(new MyTask(),cal.getTime(),200); &#125;&#125;class MyTask extends TimerTask&#123; @Override public void run() &#123; for (int i=0;i&lt;10;i++)&#123; System.out.println("放空大脑"); &#125; &#125;&#125; QUARTZ(任务调度框架) Scheduler 调度器 Trigger 触发条件 JobDetail 需要触发的JOB Job 执行逻辑 DSL（领域专用语言）Trigger和JobDetail会遇到流模式（方法链） 操作1、创建Schedule工厂2、从工厂中获取调度器3、创建JobDetail4、触发器5、调度器注册任务和触发条件6、启动 HappenBefore程序A+B的过程： 获取指令 指令解码 操作 写回结果 happenbefore即编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段 如果指令重排存在操作同一个变量，且其中一个指令为写操作，则 volatile该修饰保证得到的变量是最新的（保证线程间变量的可见性、保证数据的同步）轻量的synchronized? 单例模式对外只能有一个对象 构造器私有化 提供私有静态属性 提供公共的静态方法 相关代码懒汉式为基础的DCL模式 12345678910111213141516171819202122232425public class DoubleCheckedLocking &#123; //没有实例对象，空着的懒汉式 private static volatile DoubleCheckedLocking instance; private DoubleCheckedLocking()&#123; &#125; public static DoubleCheckedLocking getInstance()&#123; if(null != instance)&#123; return instance; &#125; synchronized (DoubleCheckedLocking.class)&#123; if(null == instance)&#123; instance = new DoubleCheckedLocking(); &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; Thread t = new Thread(()-&gt;&#123; System.out.println(DoubleCheckedLocking.getInstance()); &#125;); t.start(); System.out.println(DoubleCheckedLocking.getInstance()); &#125;&#125; ThreadLocal每个线程自身的本地、局部存储区域，每个线程只能看到自己线程的信息构造器则取决于在哪调用，在哪调用就是谁的get/set/initialValue 如果用的是InheritableThreadLocal则会继承被开辟线程的值（相当于拷贝了一份给子线程，而不是共享） 1234567891011121314151617181920212223242526272829public class ThreadLocalTest &#123; //private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;();// private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;()&#123;// @Override// protected Integer initialValue() &#123;// return 200;// &#125;// &#125;; private static ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(()-&gt;200); public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+threadLocal.get()); threadLocal.set(99); System.out.println(Thread.currentThread().getName()+"--&gt;"+threadLocal.get()); new Thread(new MyRun()).start(); new Thread(new MyRun()).start(); &#125; public static class MyRun implements Runnable&#123; @Override public void run() &#123; Thread.currentThread().setName("MyRun的线程"); threadLocal.set((int)(Math.random()*99)); System.out.println(Thread.currentThread().getName()+"--&gt;"+threadLocal.get()); &#125; &#125;&#125; 可重入锁内置锁大都支持可重入。如果某个线程试图获取一个已经由它自己持有的锁时，请求会立刻成功。可重入锁如下： 1ReentrantLock lock = new ReentrantLock(); CAS乐观锁和悲观锁的问题悲观锁就是加锁，等锁释放才能重新被使用乐观锁就是不加锁，加一个version，版本号相同才能更新 1AtomicInteger stock = new AtomicInteger(5); 原子操作会用到CAS思想，不是用的锁进一步可以学习一些java.util.concurrent]]></content>
      <categories>
        <category>program</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当Maven大片报红找不到jar包]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%BD%93Maven%E5%A4%A7%E7%89%87%E6%8A%A5%E7%BA%A2%E6%89%BE%E4%B8%8D%E5%88%B0jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[maven在导入包时在仓库中，会有找不到的包，经常大片报红 添加源然后重新下载1234567&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.M2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 如添加的Greenwich.M2，mac版本下maven默认中央仓库是没有这个jar包的，所以我给maven的setting内加上了https://repo.spring.io/milestone 12345&lt;mirror&gt; &lt;id&gt;spring&lt;/id&gt; &lt;mirrorOf&gt;spring-milestones&lt;/mirrorOf&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;&lt;/mirror&gt; 如此就可以正常get到这个版本的spring-cloud了 自己下jar包之后导入近日在添加了1.19版本的jacob时，仓库又找不到了 12345&lt;dependency&gt; &lt;groupId&gt;com.jacob&lt;/groupId&gt; &lt;artifactId&gt;jacob&lt;/artifactId&gt; &lt;version&gt;1.19&lt;/version&gt;&lt;/dependency&gt; 此时按照第一种方法应该也是可行的，不过找太麻烦了，不如下载好jar包然后maven命令导入进去 12install:install-file -DgroupId=com.jacob -DartifactId=jacob -Dversion=1.19 -Dpackaging=jar -Dfile=C:\Users\Mupa\Desktop\jacob\jacob\1.19\jacob.jar 如此使用install-file命令搞定（对应项得改），就不再报红，成功导入了]]></content>
      <categories>
        <category>program</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java里的I/O操作]]></title>
    <url>%2F2019%2F06%2F22%2Fjava%E9%87%8C%E7%9A%84I-O%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[学习如何使用Java进行输入，输出操作. I/OIO介绍流流：流动、流向，从一端（程序）移动到另一端（数据源） 数据源提供原始数据的原始媒介，常见的：数据库、文件、其他程序、内存、网络连接、IO设备。在Java中，对数据的输入/输出以流的形式进行。整个Java.io包中最重要的就是5个类和3个接口： 类 说明 File 文件类 InputStream 字节输入流 OutputStream 字节输出流 Reader 字符输入流 Writer 字符输出流 Closeable 关闭流接口 Flushable 刷新流接口 Serializable 序列化接口 流分类按流向分 输入流：数据源到程序 输出流：程序到目的地 按功能分 节点流：直接从数据源或目的地读写数据 处理流（包装流）：并不直接链接到数据源或目的地，是其他流进行封装（为了简化操作和提高性能） 节点流处于io操作的第一线，所有操作必须通过他们进行 处理流可以对其他流进行处理 按数据类型分 字节流：按字节读取数据 字符流：按字符读取数据原理“底层还是基于字节流操作，自动搜寻了指定码表 FileAPI使用规则看类的继承链看构造器 有构造器 无构造器 静态的工具类 有静态方法返回看方法 方法名 形参 返回值类型 是否为静态 相关Java测试代码1234567891011121314151617181920212223242526272829303132333435package com.mupa.io;import java.io.File;public class PathDemo01 &#123; public static void main(String[] args)&#123; String path = "/Users/xukuan/100v/JavaStudy/src/me.png"; System.out.println(File.separatorChar); //1.直接给path path = "/Users/xukuan/100v/JavaStudy/src/me.png"; System.out.println(path); //2.用常量来拼接 path = File.separatorChar + "Users" + File.separatorChar + "xukuan" + File.separatorChar + "100v" + File.separatorChar + "JavaStudy" + File.separatorChar + "src" + File.separatorChar + "me.png"; System.out.println(path); //3.构建File对象 File src = new File(path); System.out.println(src.length()); //4.构建File对象 src = new File("/Users/xukuan/100v/JavaStudy/src" , "me.png"); System.out.println(src.length()); //5.构建File对象 src = new File(new File("/Users/xukuan/100v/JavaStudy/src"),"me.png"); System.out.println(src.length()); //6.相对路径 src = new File(path); System.out.println(src.getAbsoluteFile()); //7.相对路径 System.out.println(System.getProperty("user.dir")); src = new File("src/me.png"); System.out.println(src.length()); //8.构建一个不存在的文件 src = new File("src/test.png"); System.out.println(src.getAbsoluteFile()); &#125;&#125; API学习文件操作相关API API 说明 getName() 获得文件名 getPath() 获得相对\绝对路径（取决于构建） getAbsolutePath() 获得绝对路径 getParent() 获得父路径，没有则返回空 getParentFile() 获得父路径对象 exists() 判断是否存在 isFile() 是否为文件 isDictionary() 是否为文件夹 length() 方法返回文件的长度（字节数） creatNewFile() 不存在则创建文件，返回bool，不能创建文件夹 delete() 删除已经存在的文件 相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.io.File;import java.io.IOException;public class FileDemo &#123; public static void main(String[] args) throws IOException &#123; File src = new File("F:\\100v\\Learn\\io.jpg"); System.out.println("名称:"+src.getName()); System.out.println("路径:"+src.getPath()); System.out.println("绝对路径:"+src.getAbsolutePath()); System.out.println("相对路径:"+src.getParent()); System.out.println("父对象:"+src.getParentFile().getName()); System.out.println("========================================="); File src2 = new File("Learn/io.jpg"); System.out.println(src2.getAbsolutePath()); System.out.println("是否存在："+src2.exists()); System.out.println("是否文件："+src2.isFile()); System.out.println("是否文件夹："+src2.isDirectory()); System.out.println("========================================="); File src3 = new File("io.jpg"); System.out.println(src3.getAbsolutePath()); System.out.println("是否存在："+src3.exists()); System.out.println("是否文件："+src3.isFile()); System.out.println("是否文件夹："+src3.isDirectory()); System.out.println("========================================="); File src4 = new File("F:\\100v\\Learn"); System.out.println(src4.getAbsolutePath()); System.out.println("是否存在："+src4.exists()); System.out.println("是否文件："+src4.isFile()); System.out.println("是否文件夹："+src4.isDirectory()); System.out.println("========================================="); src = new File("xxx"); if(!src.exists())&#123; System.out.println("不存在"); &#125;else&#123; if(src.isFile())&#123; System.out.println("文件"); &#125;else&#123; System.out.println("文件夹"); &#125; &#125; System.out.println("========================================="); src = new File("F:\\100v\\Learn\\io.jpg"); System.out.println("长度："+src.length()); src = new File("F:\\100v\\Learn"); System.out.println("长度："+src.length()); System.out.println("========================================="); src = new File("F:\\100v\\Learn\\io.txt"); boolean flag = src.createNewFile(); System.out.println(flag); System.out.println("========================================="); src = new File("F:\\100v\\Learn\\test"); flag = src.createNewFile(); System.out.println(flag); System.out.println("========================================="); flag = src.delete(); System.out.println(flag); &#125;&#125; 文件夹操作相关API API 说明 mkdir() mkdirs 创建目录，如果父目录链不存在一同创建 list() 下级名称 listFiles() 下级File listRoots() 根路径（盘符） 相关代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.File;import java.io.IOException;public class FileDemo &#123; public static void main(String[] args) throws IOException &#123; File dir = new File("F:\\100v\\Learn\\dir\\test"); boolean flag = dir.mkdirs(); System.out.println(flag); dir = new File("F:\\100v\\Learn\\dir\\test2"); flag = dir.mkdir(); System.out.println(flag); System.out.println("================================"); dir = new File("F:\\100v\\Learn"); //下级名称list String[] subNames = dir.list(); for(String s:subNames)&#123; System.out.println(s); &#125; System.out.println("================================"); //下级对象listFiles File[] subFiles = dir.listFiles(); for(File s:subFiles)&#123; System.out.println(s.getAbsolutePath()); &#125; System.out.println("================================"); //所有盘符 File[] roots = dir.listRoots(); for(File r:roots)&#123; System.out.println(r.getAbsolutePath()); &#125; System.out.println("================================"); //递归获得子孙级目录和文件名称 File src = new File("F:\\100v\\Learn"); printName(src,0); System.out.println("================================"); //获取文件夹大小 src = new File("F:\\100v\\Learn"); count(src); System.out.println(len +"字节" ); &#125; public static void printName(File src,int deep)&#123; //控制层次 for(int i=0 ;i&lt;deep;i++)&#123; System.out.print("-"); &#125; //打印名称 System.out.println(src.getName()); if(null == src || !src.exists())&#123;//递归头 return ; &#125;else if(src.isDirectory())&#123;//递归体 for(File s:src.listFiles())&#123; printName(s,deep + 1); &#125; &#125; &#125; private static long len=0; public static void count(File src)&#123; if(null != src &amp;&amp; src.exists())&#123;//递归头 if(src.isFile())&#123; len+=src.length(); &#125;else&#123; for(File s:src.listFiles())&#123; count(s); &#125; &#125; &#125; &#125;&#125; 编码和解码、乱码编码默认使用工程字符集，可以改用其他字符集 12getBytes()getBytes(“GBK”) 解码字符解码时需要信息为bytes、offset、length和字符集名称 1new String(datas,0,datas.length-2,&quot;UTF-16LE&quot;) 乱码 字符长度不正确 字符集不同 相关代码1234567891011121314151617181920212223import java.io.File;import java.io.IOException;public class FileDemo &#123; public static void main(String[] args) throws IOException &#123; String msg = "性命生命使命a"; //编码：字节数组 byte[] datas = msg.getBytes(); System.out.println(datas.length); //编码：其他字符集 datas = msg.getBytes("UTF-16LE"); System.out.println(datas.length); //解码：字符串（byte[] bytes,int offset,int length,String charsetName） msg = new String(datas,0,datas.length-2,"UTF-16LE"); System.out.println(msg); //乱码：字节数不够 msg = new String(datas,0,datas.length-1,"UTF-16LE"); System.out.println(msg); //乱码：字符集不统一 msg = new String(datas,0,datas.length-1,"gbk"); System.out.println(msg); &#125;&#125; 输入输出流四个抽象类 抽象类 说明 常用方法 InputStream 字节输入流的父类，数据单位为字节 int read()、void close() OutputStream 字节输出流的父类，数据单位为字节 void write(int)、void flush()、void close() Reader 字符输入流的父类，数据单位为字符 int read()、void close() Writer 字符输出流的父类，数据单位为字符 void write(String)、void flush()、void close() IO的标准操作操作流程 创建源 选择流 操作 释放资源相关代码123456789101112131415161718192021222324252627282930import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); //选择流 InputStream is = null; try &#123; is = new FileInputStream(src); //操作 int temp; while((temp=is.read())!=-1)&#123; System.out.println((char)temp); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=is)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 文件字节流输入流FileInputStream除了在IO标准操作时演示的，直接read()外，可以用数组做缓冲，相关代码如下： 1234567891011121314151617181920212223242526272829303132import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); //选择流 InputStream is = null; try &#123; is = new FileInputStream(src); //操作 byte[] flush = new byte[1024];//缓冲容器 int len = -1;//接收长度 while((len=is.read(flush))!=-1)&#123; String str = new String(flush,0,len); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=is)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 输出流FileOutputStream输出流同样是根据操作顺序进行操作，最后可以flush减轻内存压力，代码如下： 123456789101112131415161718192021222324252627282930import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); //选择流 OutputStream os = null; try &#123; os = new FileOutputStream(src,true); //操作 String msg = "hello"; byte[] datas = msg.getBytes(); os.write(datas,0,datas.length); os.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=os)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 文件拷贝即以上输入流和输出流的合二为一，代码如下： 1234567891011121314151617181920212223242526272829303132333435import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); File dest = new File("F:\\100v\\Learn\\iocopy.txt"); //选择流 InputStream is = null; OutputStream os = null; try &#123; is = new FileInputStream(src); os = new FileOutputStream(dest); //操作 byte[] flush = new byte[1024]; int len = -1; while((len=is.read(flush))!=-1)&#123; os.write(flush,0,len); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=os)&#123; try &#123; os.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 文件字符流输入流FileReader读中文时，可以直接用char来读，代码如下： 1234567891011121314151617181920212223242526272829303132import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); //选择流 Reader reader = null; try &#123; reader = new FileReader(src); //操作 char[] flush = new char[1024]; int len = -1; while((len=reader.read(flush))!=-1)&#123; String str = new String(flush,0,len); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=reader)&#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 输出流FileWriter代码如下 123456789101112131415161718192021222324252627282930313233343536import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); //选择流 Writer writer = null; try &#123; writer = new FileWriter(src); //操作 //写法一（写出）// String msg = "IO is so easy可怕\r\n";// char[] datas = msg.toCharArray();// writer.write(datas,0,datas.length); //写法二（直接扔）// String msg = "IO is so easy可sdsad怕\r\n";// writer.write(msg); //写法三（append） writer.append("IO is so easy").append("可sdsad怕\\r\\n"); writer.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=writer)&#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 字节数组输入、输出流字节数组输入流ByteArrayInputStream和前面的文件输入流相比： 源头时字节数组（不要太大、内存会爆掉） 释放资源可以不用处理 字节数组输出流ByteArrayOutputStream和前面的文件输出流相比： 不用定义目的地（内部维护） 选择流不用关联 释放资源可以不用处理 要通过toByteArray取一下，否则在内存里了 处理流设计模式为了达到一个目的，用固定的方法组织代码 装饰器模式 抽象组件：需要装饰的抽象对象（接口或抽象父类） 具体组件：需要装饰的对象 抽象装饰类：包含了对抽象组件的引用及装饰着共有的方法 具体装饰类：被装饰的对象 相关代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; Drink coffee = new Coffee(); Drink suger = new Suger(coffee); System.out.println(suger.info()+"---&gt;"+suger.cost()); Drink milk = new Milk(suger); System.out.println(milk.info()+"---&gt;"+milk.cost()); &#125;&#125;interface Drink&#123; double cost(); String info();&#125;class Coffee implements Drink&#123; private String name = "原味咖啡"; @Override public double cost() &#123; return 10; &#125; @Override public String info() &#123; return name; &#125;&#125;abstract class Decorate implements Drink&#123; private Drink drink; public Decorate(Drink drink) &#123; this.drink = drink; &#125; @Override public double cost() &#123; return this.drink.cost(); &#125; @Override public String info() &#123; return this.drink.info(); &#125;&#125;class Milk extends Decorate&#123; public Milk(Drink drink) &#123; super(drink); &#125; @Override public double cost() &#123; return super.cost()*4; &#125; @Override public String info() &#123; return super.info()+"加入了牛奶"; &#125;&#125;class Suger extends Decorate&#123; public Suger(Drink drink) &#123; super(drink); &#125; @Override public double cost() &#123; return super.cost()*2; &#125; @Override public String info() &#123; return super.info()+"加入了蔗糖"; &#125;&#125; 缓冲流 提升性能 必须有节点流做支撑 可以直接释放外面的装饰流，它会自动去先释放内部的节点流 字节缓冲流BufferedInputStream&amp;BufferedOutputStream默认有8k的缓冲区使用方法可以参见装饰器设计模式,套一层足以 1InputStream is = new BufferedInputStream(new FileInputStream(src)); 字符缓冲流BufferedReader和BufferedWriter 仅限于纯文本 BufferedReader可以不用再使用byte[] 可以直接用readLine() BufferedWriter可以不用再换行可以直接bw.write(line);bw.newLine(); 转换流InputStreamReader&amp;OutputStreamWriter 将字节流转换成字符流，前提是字节流是纯文本的内容 可以指定字符集 相关代码12345678910111213141516171819202122232425import jdk.internal.util.xml.impl.Input;import java.io.*;import java.net.URL;public class FileDemo &#123; public static void main(String[] args) &#123; try(BufferedReader reader= new BufferedReader( new InputStreamReader( new URL("http://www.baidu.com").openStream(),"UTF-8")); BufferedWriter writer= new BufferedWriter( new OutputStreamWriter( new FileOutputStream("baidu.html"),"UTF-8")); )&#123; String msg; while ((msg=reader.readLine())!=null)&#123; writer.write(msg); writer.newLine(); &#125; &#125;catch(IOException e)&#123; System.out.println("IO异常"); &#125; &#125;&#125; 数据流DataInputStream&amp;DataOutputStream 可以保存数据的数据类型 读取的顺序和取出的顺序保持一致 先写出后读取 相关代码123456789101112131415161718192021import jdk.internal.util.xml.impl.Input;import java.io.*;import java.net.URL;public class FileDemo &#123; public static void main(String[] args) throws IOException &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); DataOutputStream dos = new DataOutputStream(baos); dos.writeUTF("你好"); dos.writeInt(18); dos.writeBoolean(true); dos.writeChar('a'); dos.flush(); byte[] datas = baos.toByteArray(); System.out.println(datas.length); DataInputStream dis = new DataInputStream(new ByteArrayInputStream(datas)); System.out.println(dis.readUTF()); System.out.println(dis.readInt()); &#125;&#125; 对象流ObjectInputStream&amp;ObjectOutputStream 输出流对应序列化（持久化） 输入流对应反序列化 和数据流其实差不多 不是所有的对象都可以序列化 在读取的时候，我们需要将其强转为对应的类型 相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243import jdk.internal.util.xml.impl.Input;import java.io.*;import java.net.URL;public class FileDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; FileOutputStream fos = new FileOutputStream("io.txt"); ObjectOutputStream dos = new ObjectOutputStream(fos); dos.writeUTF("你好"); dos.writeInt(18); dos.writeBoolean(true); dos.writeChar('a'); Test test = new Test("xukuan","programmer"); dos.writeObject(test); dos.flush(); ObjectInputStream dis = new ObjectInputStream(new FileInputStream("io.txt")); System.out.println(dis.readUTF()); System.out.println(dis.readInt()); System.out.println(dis.readBoolean()); System.out.println(dis.readChar()); Object otest = dis.readObject(); if(otest instanceof Test)&#123; Test testobj = (Test) otest; System.out.println(testobj); &#125; &#125;&#125;class Test implements Serializable&#123; private String name; private String job; public Test(String name, String job) &#123; this.name = name; this.job = job; &#125; @Override public String toString() &#123; return name+" is a "+job; &#125;&#125; 注意，对于不需要序列化的变量 可以添加 transient声明 打印流PrintStream&amp;PrintWrite PrintStream就是我们日常输Println出用的流 PrintWrite与前者大同小异，区别在于对Write提供了处理 相关代码1234567891011121314151617181920212223242526272829import jdk.internal.cmm.SystemResourcePressureImpl;import jdk.internal.util.xml.impl.Input;import org.omg.Messaging.SYNC_WITH_TRANSPORT;import java.io.*;import java.net.URL;public class FileDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; PrintStream ps = System.out; ps.println("打印流"); ps.println(true); ps = new PrintStream(new BufferedOutputStream(new FileOutputStream("test.txt")),true); ps.println("打印流"); ps.println(true); //重定向输出端 System.setOut(ps); System.out.println("hello"); System.setOut(new PrintStream(new BufferedOutputStream(new FileOutputStream(FileDescriptor.out)),true)); System.out.println("im backing"); PrintWriter pw = new PrintWriter(new BufferedOutputStream(new FileOutputStream("hello.txt")),true); pw.println("打印流"); pw.println(true); pw.close(); &#125;&#125; 文件分割与合并RandomAccessFile 支持读取和写入随机访问文件 seek()设置文件的指针偏移 相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.mupa.io;import java.io.*;import java.util.ArrayList;import java.util.List;public class SplitFile &#123; private File src; private String destDir; private List&lt;String&gt; destPaths; private int blockSize; private int size; private long len; public SplitFile(String srcPath, String destDir, int blockSize) &#123; this.src = new File(srcPath); this.destDir = destDir; this.blockSize = blockSize; this.destPaths = new ArrayList&lt;String&gt;(); init(); &#125; private void init() &#123; this.len = this.src.length(); this.size = (int) Math.ceil(this.len*1.0/blockSize); for(int i=0;i&lt;size;i++)&#123; this.destPaths.add(this.destDir+"/"+i+"-"+this.src.getName()); &#125; &#125; private void split() throws IOException &#123; int beginPos = 0; int actualSize = (int)(blockSize&gt;len?len:blockSize); for(int i=0;i&lt;size;i++)&#123; beginPos = i*blockSize; if(i==size-1)&#123; actualSize = (int)len; &#125;else&#123; actualSize = blockSize; len -=actualSize; &#125; System.out.println("正在输出块"+i); splitDetail(i,beginPos,actualSize); &#125; &#125; private void splitDetail(int i, int beginPos, int actualSize) throws IOException &#123; RandomAccessFile raf = new RandomAccessFile(this.src,"r"); RandomAccessFile raf2 = new RandomAccessFile(this.destPaths.get(i),"rw"); raf.seek(beginPos); byte[] flush = new byte[1024]; int len = -1; while((len=raf.read(flush))!=-1)&#123; if(actualSize&gt;len)&#123; raf2.write(flush,0,len); actualSize-=len; &#125;else&#123; raf2.write(flush,0,actualSize); break; &#125; &#125; raf2.close(); raf.close(); &#125; public void merge(String destPath) throws IOException &#123; OutputStream os = new BufferedOutputStream(new FileOutputStream(destPath,true)); for(int i=0;i&lt;size;i++)&#123; InputStream is = new BufferedInputStream(new FileInputStream(destPaths.get(i))); byte[] flush = new byte[1024]; int len=-1; while((len=is.read(flush))!=-1)&#123; os.write(flush,0,len); &#125; os.flush(); is.close(); &#125; os.close(); &#125; public static void main(String[] args) throws IOException &#123; SplitFile sf = new SplitFile("src/me.png","src/dest",1024); sf.split(); sf.merge("aaa.png"); &#125;&#125; 文件合并SequenceInputStream 可以吧多个输入流合并到一起然后将文件合并 使用Vector容器，载入到SequenceInputStream 相关代码123456789101112131415161718public void merge(String destPath) throws IOException &#123; OutputStream os = new BufferedOutputStream(new FileOutputStream(destPath,true)); Vector&lt;InputStream&gt; vi = new Vector&lt;&gt;(); SequenceInputStream sis = null; for(int i=0;i&lt;size;i++)&#123; vi.add(new BufferedInputStream(new FileInputStream(destPaths.get(i)))); &#125; sis = new SequenceInputStream(vi.elements()); byte[] flush = new byte[1024]; int len=-1; while((len=sis.read(flush))!=-1)&#123; os.write(flush,0,len); &#125; os.flush(); sis.close(); os.close(); &#125; CommonsIOFileUtils读写相关： sizeof()统计文件大小 listFiles(地址，文件过滤，目录过滤)遍历文件 readFileToString(地址，编码)读取文件内容 readFileToByteArray(地址)读文件为字符数组 readLines(地址，编码)逐行读取 lineIterator(地址，编码)迭代器读取方法 write(地址，内容，编码) writeStringToFile(地址，内容，编码，追加) writeByteArrayToFile(地址，字符数组，追加) writeLines(地址，List，间隔符，追加) 拷贝相关： copyFile(源文件地址，目的文件地址)拷贝文件 copyFileToDir(源文件地址，目的目录地址)拷贝文件到目录 copyDirectoryToDirectory(源目录地址，目的目录地址)复制目录到目录 copyDirectory(源目录地址，目的目录地址)复制目录内的内容到目的目录 copyURLToFile(URL，文件地址)拷贝URL的内容——如果是文字可以用IOUtils.toString(URL，编码)]]></content>
      <categories>
        <category>program</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
</search>
