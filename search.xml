<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[当Maven大片报红找不到jar包]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%BD%93Maven%E5%A4%A7%E7%89%87%E6%8A%A5%E7%BA%A2%E6%89%BE%E4%B8%8D%E5%88%B0jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[maven在导入包时在仓库中，会有找不到的包，经常大片报红 添加源然后重新下载1234567&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.M2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 如添加的Greenwich.M2，mac版本下maven默认中央仓库是没有这个jar包的，所以我给maven的setting内加上了https://repo.spring.io/milestone 12345&lt;mirror&gt; &lt;id&gt;spring&lt;/id&gt; &lt;mirrorOf&gt;spring-milestones&lt;/mirrorOf&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;&lt;/mirror&gt; 如此就可以正常get到这个版本的spring-cloud了 自己下jar包之后导入近日在添加了1.19版本的jacob时，仓库又找不到了 12345&lt;dependency&gt; &lt;groupId&gt;com.jacob&lt;/groupId&gt; &lt;artifactId&gt;jacob&lt;/artifactId&gt; &lt;version&gt;1.19&lt;/version&gt;&lt;/dependency&gt; 此时按照第一种方法应该也是可行的，不过找太麻烦了，不如下载好jar包然后maven命令导入进去 12install:install-file -DgroupId=com.jacob -DartifactId=jacob -Dversion=1.19 -Dpackaging=jar -Dfile=C:\Users\Mupa\Desktop\jacob\jacob\1.19\jacob.jar 如此使用install-file命令搞定（对应项得改），就不再报红，成功导入了]]></content>
      <categories>
        <category>program</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java里的I/O操作]]></title>
    <url>%2F2019%2F06%2F22%2Fjava%E9%87%8C%E7%9A%84I-O%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[学习如何使用Java进行输入，输出操作. I/OIO介绍流流：流动、流向，从一端（程序）移动到另一端（数据源） 数据源提供原始数据的原始媒介，常见的：数据库、文件、其他程序、内存、网络连接、IO设备。在Java中，对数据的输入/输出以流的形式进行。整个Java.io包中最重要的就是5个类和3个接口： 类 说明 File 文件类 InputStream 字节输入流 OutputStream 字节输出流 Reader 字符输入流 Writer 字符输出流 Closeable 关闭流接口 Flushable 刷新流接口 Serializable 序列化接口 流分类按流向分 输入流：数据源到程序 输出流：程序到目的地 按功能分 节点流：直接从数据源或目的地读写数据 处理流（包装流）：并不直接链接到数据源或目的地，是其他流进行封装（为了简化操作和提高性能） 节点流处于io操作的第一线，所有操作必须通过他们进行 处理流可以对其他流进行处理 按数据类型分 字节流：按字节读取数据 字符流：按字符读取数据原理“底层还是基于字节流操作，自动搜寻了指定码表 FileAPI使用规则看类的继承链看构造器 有构造器 无构造器 静态的工具类 有静态方法返回看方法 方法名 形参 返回值类型 是否为静态 相关Java测试代码1234567891011121314151617181920212223242526272829303132333435package com.mupa.io;import java.io.File;public class PathDemo01 &#123; public static void main(String[] args)&#123; String path = "/Users/xukuan/100v/JavaStudy/src/me.png"; System.out.println(File.separatorChar); //1.直接给path path = "/Users/xukuan/100v/JavaStudy/src/me.png"; System.out.println(path); //2.用常量来拼接 path = File.separatorChar + "Users" + File.separatorChar + "xukuan" + File.separatorChar + "100v" + File.separatorChar + "JavaStudy" + File.separatorChar + "src" + File.separatorChar + "me.png"; System.out.println(path); //3.构建File对象 File src = new File(path); System.out.println(src.length()); //4.构建File对象 src = new File("/Users/xukuan/100v/JavaStudy/src" , "me.png"); System.out.println(src.length()); //5.构建File对象 src = new File(new File("/Users/xukuan/100v/JavaStudy/src"),"me.png"); System.out.println(src.length()); //6.相对路径 src = new File(path); System.out.println(src.getAbsoluteFile()); //7.相对路径 System.out.println(System.getProperty("user.dir")); src = new File("src/me.png"); System.out.println(src.length()); //8.构建一个不存在的文件 src = new File("src/test.png"); System.out.println(src.getAbsoluteFile()); &#125;&#125; API学习文件操作相关API API 说明 getName() 获得文件名 getPath() 获得相对\绝对路径（取决于构建） getAbsolutePath() 获得绝对路径 getParent() 获得父路径，没有则返回空 getParentFile() 获得父路径对象 exists() 判断是否存在 isFile() 是否为文件 isDictionary() 是否为文件夹 length() 方法返回文件的长度（字节数） creatNewFile() 不存在则创建文件，返回bool，不能创建文件夹 delete() 删除已经存在的文件 相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.io.File;import java.io.IOException;public class FileDemo &#123; public static void main(String[] args) throws IOException &#123; File src = new File("F:\\100v\\Learn\\io.jpg"); System.out.println("名称:"+src.getName()); System.out.println("路径:"+src.getPath()); System.out.println("绝对路径:"+src.getAbsolutePath()); System.out.println("相对路径:"+src.getParent()); System.out.println("父对象:"+src.getParentFile().getName()); System.out.println("========================================="); File src2 = new File("Learn/io.jpg"); System.out.println(src2.getAbsolutePath()); System.out.println("是否存在："+src2.exists()); System.out.println("是否文件："+src2.isFile()); System.out.println("是否文件夹："+src2.isDirectory()); System.out.println("========================================="); File src3 = new File("io.jpg"); System.out.println(src3.getAbsolutePath()); System.out.println("是否存在："+src3.exists()); System.out.println("是否文件："+src3.isFile()); System.out.println("是否文件夹："+src3.isDirectory()); System.out.println("========================================="); File src4 = new File("F:\\100v\\Learn"); System.out.println(src4.getAbsolutePath()); System.out.println("是否存在："+src4.exists()); System.out.println("是否文件："+src4.isFile()); System.out.println("是否文件夹："+src4.isDirectory()); System.out.println("========================================="); src = new File("xxx"); if(!src.exists())&#123; System.out.println("不存在"); &#125;else&#123; if(src.isFile())&#123; System.out.println("文件"); &#125;else&#123; System.out.println("文件夹"); &#125; &#125; System.out.println("========================================="); src = new File("F:\\100v\\Learn\\io.jpg"); System.out.println("长度："+src.length()); src = new File("F:\\100v\\Learn"); System.out.println("长度："+src.length()); System.out.println("========================================="); src = new File("F:\\100v\\Learn\\io.txt"); boolean flag = src.createNewFile(); System.out.println(flag); System.out.println("========================================="); src = new File("F:\\100v\\Learn\\test"); flag = src.createNewFile(); System.out.println(flag); System.out.println("========================================="); flag = src.delete(); System.out.println(flag); &#125;&#125; 文件夹操作相关API API 说明 mkdir() mkdirs 创建目录，如果父目录链不存在一同创建 list() 下级名称 listFiles() 下级File listRoots() 根路径（盘符） 相关代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.File;import java.io.IOException;public class FileDemo &#123; public static void main(String[] args) throws IOException &#123; File dir = new File("F:\\100v\\Learn\\dir\\test"); boolean flag = dir.mkdirs(); System.out.println(flag); dir = new File("F:\\100v\\Learn\\dir\\test2"); flag = dir.mkdir(); System.out.println(flag); System.out.println("================================"); dir = new File("F:\\100v\\Learn"); //下级名称list String[] subNames = dir.list(); for(String s:subNames)&#123; System.out.println(s); &#125; System.out.println("================================"); //下级对象listFiles File[] subFiles = dir.listFiles(); for(File s:subFiles)&#123; System.out.println(s.getAbsolutePath()); &#125; System.out.println("================================"); //所有盘符 File[] roots = dir.listRoots(); for(File r:roots)&#123; System.out.println(r.getAbsolutePath()); &#125; System.out.println("================================"); //递归获得子孙级目录和文件名称 File src = new File("F:\\100v\\Learn"); printName(src,0); System.out.println("================================"); //获取文件夹大小 src = new File("F:\\100v\\Learn"); count(src); System.out.println(len +"字节" ); &#125; public static void printName(File src,int deep)&#123; //控制层次 for(int i=0 ;i&lt;deep;i++)&#123; System.out.print("-"); &#125; //打印名称 System.out.println(src.getName()); if(null == src || !src.exists())&#123;//递归头 return ; &#125;else if(src.isDirectory())&#123;//递归体 for(File s:src.listFiles())&#123; printName(s,deep + 1); &#125; &#125; &#125; private static long len=0; public static void count(File src)&#123; if(null != src &amp;&amp; src.exists())&#123;//递归头 if(src.isFile())&#123; len+=src.length(); &#125;else&#123; for(File s:src.listFiles())&#123; count(s); &#125; &#125; &#125; &#125;&#125; 编码和解码、乱码编码默认使用工程字符集，可以改用其他字符集 12getBytes()getBytes(“GBK”) 解码字符解码时需要信息为bytes、offset、length和字符集名称 1new String(datas,0,datas.length-2,&quot;UTF-16LE&quot;) 乱码 字符长度不正确 字符集不同 相关代码1234567891011121314151617181920212223import java.io.File;import java.io.IOException;public class FileDemo &#123; public static void main(String[] args) throws IOException &#123; String msg = "性命生命使命a"; //编码：字节数组 byte[] datas = msg.getBytes(); System.out.println(datas.length); //编码：其他字符集 datas = msg.getBytes("UTF-16LE"); System.out.println(datas.length); //解码：字符串（byte[] bytes,int offset,int length,String charsetName） msg = new String(datas,0,datas.length-2,"UTF-16LE"); System.out.println(msg); //乱码：字节数不够 msg = new String(datas,0,datas.length-1,"UTF-16LE"); System.out.println(msg); //乱码：字符集不统一 msg = new String(datas,0,datas.length-1,"gbk"); System.out.println(msg); &#125;&#125; 输入输出流四个抽象类 抽象类 说明 常用方法 InputStream 字节输入流的父类，数据单位为字节 int read()、void close() OutputStream 字节输出流的父类，数据单位为字节 void write(int)、void flush()、void close() Reader 字符输入流的父类，数据单位为字符 int read()、void close() Writer 字符输出流的父类，数据单位为字符 void write(String)、void flush()、void close() IO的标准操作操作流程 创建源 选择流 操作 释放资源相关代码123456789101112131415161718192021222324252627282930import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); //选择流 InputStream is = null; try &#123; is = new FileInputStream(src); //操作 int temp; while((temp=is.read())!=-1)&#123; System.out.println((char)temp); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=is)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 文件字节流输入流FileInputStream除了在IO标准操作时演示的，直接read()外，可以用数组做缓冲，相关代码如下： 1234567891011121314151617181920212223242526272829303132import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); //选择流 InputStream is = null; try &#123; is = new FileInputStream(src); //操作 byte[] flush = new byte[1024];//缓冲容器 int len = -1;//接收长度 while((len=is.read(flush))!=-1)&#123; String str = new String(flush,0,len); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=is)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 输出流FileOutputStream输出流同样是根据操作顺序进行操作，最后可以flush减轻内存压力，代码如下： 123456789101112131415161718192021222324252627282930import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); //选择流 OutputStream os = null; try &#123; os = new FileOutputStream(src,true); //操作 String msg = "hello"; byte[] datas = msg.getBytes(); os.write(datas,0,datas.length); os.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=os)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 文件拷贝即以上输入流和输出流的合二为一，代码如下： 1234567891011121314151617181920212223242526272829303132333435import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); File dest = new File("F:\\100v\\Learn\\iocopy.txt"); //选择流 InputStream is = null; OutputStream os = null; try &#123; is = new FileInputStream(src); os = new FileOutputStream(dest); //操作 byte[] flush = new byte[1024]; int len = -1; while((len=is.read(flush))!=-1)&#123; os.write(flush,0,len); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=os)&#123; try &#123; os.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 文件字符流输入流FileReader读中文时，可以直接用char来读，代码如下： 1234567891011121314151617181920212223242526272829303132import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); //选择流 Reader reader = null; try &#123; reader = new FileReader(src); //操作 char[] flush = new char[1024]; int len = -1; while((len=reader.read(flush))!=-1)&#123; String str = new String(flush,0,len); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=reader)&#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 输出流FileWriter代码如下 123456789101112131415161718192021222324252627282930313233343536import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; //创建源 File src = new File("F:\\100v\\Learn\\io.txt"); //选择流 Writer writer = null; try &#123; writer = new FileWriter(src); //操作 //写法一（写出）// String msg = "IO is so easy可怕\r\n";// char[] datas = msg.toCharArray();// writer.write(datas,0,datas.length); //写法二（直接扔）// String msg = "IO is so easy可sdsad怕\r\n";// writer.write(msg); //写法三（append） writer.append("IO is so easy").append("可sdsad怕\\r\\n"); writer.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(null!=writer)&#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 字节数组输入、输出流字节数组输入流ByteArrayInputStream和前面的文件输入流相比： 源头时字节数组（不要太大、内存会爆掉） 释放资源可以不用处理 字节数组输出流ByteArrayOutputStream和前面的文件输出流相比： 不用定义目的地（内部维护） 选择流不用关联 释放资源可以不用处理 要通过toByteArray取一下，否则在内存里了 处理流设计模式为了达到一个目的，用固定的方法组织代码 装饰器模式 抽象组件：需要装饰的抽象对象（接口或抽象父类） 具体组件：需要装饰的对象 抽象装饰类：包含了对抽象组件的引用及装饰着共有的方法 具体装饰类：被装饰的对象 相关代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import jdk.internal.util.xml.impl.Input;import java.io.*;public class FileDemo &#123; public static void main(String[] args) &#123; Drink coffee = new Coffee(); Drink suger = new Suger(coffee); System.out.println(suger.info()+"---&gt;"+suger.cost()); Drink milk = new Milk(suger); System.out.println(milk.info()+"---&gt;"+milk.cost()); &#125;&#125;interface Drink&#123; double cost(); String info();&#125;class Coffee implements Drink&#123; private String name = "原味咖啡"; @Override public double cost() &#123; return 10; &#125; @Override public String info() &#123; return name; &#125;&#125;abstract class Decorate implements Drink&#123; private Drink drink; public Decorate(Drink drink) &#123; this.drink = drink; &#125; @Override public double cost() &#123; return this.drink.cost(); &#125; @Override public String info() &#123; return this.drink.info(); &#125;&#125;class Milk extends Decorate&#123; public Milk(Drink drink) &#123; super(drink); &#125; @Override public double cost() &#123; return super.cost()*4; &#125; @Override public String info() &#123; return super.info()+"加入了牛奶"; &#125;&#125;class Suger extends Decorate&#123; public Suger(Drink drink) &#123; super(drink); &#125; @Override public double cost() &#123; return super.cost()*2; &#125; @Override public String info() &#123; return super.info()+"加入了蔗糖"; &#125;&#125; 缓冲流 提升性能 必须有节点流做支撑 可以直接释放外面的装饰流，它会自动去先释放内部的节点流 字节缓冲流BufferedInputStream&amp;BufferedOutputStream默认有8k的缓冲区使用方法可以参见装饰器设计模式,套一层足以 1InputStream is = new BufferedInputStream(new FileInputStream(src)); 字符缓冲流BufferedReader和BufferedWriter 仅限于纯文本 BufferedReader可以不用再使用byte[] 可以直接用readLine() BufferedWriter可以不用再换行可以直接bw.write(line);bw.newLine(); 转换流InputStreamReader&amp;OutputStreamWriter 将字节流转换成字符流，前提是字节流是纯文本的内容 可以指定字符集 相关代码12345678910111213141516171819202122232425import jdk.internal.util.xml.impl.Input;import java.io.*;import java.net.URL;public class FileDemo &#123; public static void main(String[] args) &#123; try(BufferedReader reader= new BufferedReader( new InputStreamReader( new URL("http://www.baidu.com").openStream(),"UTF-8")); BufferedWriter writer= new BufferedWriter( new OutputStreamWriter( new FileOutputStream("baidu.html"),"UTF-8")); )&#123; String msg; while ((msg=reader.readLine())!=null)&#123; writer.write(msg); writer.newLine(); &#125; &#125;catch(IOException e)&#123; System.out.println("IO异常"); &#125; &#125;&#125; 数据流DataInputStream&amp;DataOutputStream 可以保存数据的数据类型 读取的顺序和取出的顺序保持一致 先写出后读取 相关代码123456789101112131415161718192021import jdk.internal.util.xml.impl.Input;import java.io.*;import java.net.URL;public class FileDemo &#123; public static void main(String[] args) throws IOException &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); DataOutputStream dos = new DataOutputStream(baos); dos.writeUTF("你好"); dos.writeInt(18); dos.writeBoolean(true); dos.writeChar('a'); dos.flush(); byte[] datas = baos.toByteArray(); System.out.println(datas.length); DataInputStream dis = new DataInputStream(new ByteArrayInputStream(datas)); System.out.println(dis.readUTF()); System.out.println(dis.readInt()); &#125;&#125; 对象流ObjectInputStream&amp;ObjectOutputStream 输出流对应序列化（持久化） 输入流对应反序列化 和数据流其实差不多 不是所有的对象都可以序列化 在读取的时候，我们需要将其强转为对应的类型 相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243import jdk.internal.util.xml.impl.Input;import java.io.*;import java.net.URL;public class FileDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; FileOutputStream fos = new FileOutputStream("io.txt"); ObjectOutputStream dos = new ObjectOutputStream(fos); dos.writeUTF("你好"); dos.writeInt(18); dos.writeBoolean(true); dos.writeChar('a'); Test test = new Test("xukuan","programmer"); dos.writeObject(test); dos.flush(); ObjectInputStream dis = new ObjectInputStream(new FileInputStream("io.txt")); System.out.println(dis.readUTF()); System.out.println(dis.readInt()); System.out.println(dis.readBoolean()); System.out.println(dis.readChar()); Object otest = dis.readObject(); if(otest instanceof Test)&#123; Test testobj = (Test) otest; System.out.println(testobj); &#125; &#125;&#125;class Test implements Serializable&#123; private String name; private String job; public Test(String name, String job) &#123; this.name = name; this.job = job; &#125; @Override public String toString() &#123; return name+" is a "+job; &#125;&#125; 注意，对于不需要序列化的变量 可以添加 transient声明 打印流PrintStream&amp;PrintWrite PrintStream就是我们日常输Println出用的流 PrintWrite与前者大同小异，区别在于对Write提供了处理 相关代码1234567891011121314151617181920212223242526272829import jdk.internal.cmm.SystemResourcePressureImpl;import jdk.internal.util.xml.impl.Input;import org.omg.Messaging.SYNC_WITH_TRANSPORT;import java.io.*;import java.net.URL;public class FileDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; PrintStream ps = System.out; ps.println("打印流"); ps.println(true); ps = new PrintStream(new BufferedOutputStream(new FileOutputStream("test.txt")),true); ps.println("打印流"); ps.println(true); //重定向输出端 System.setOut(ps); System.out.println("hello"); System.setOut(new PrintStream(new BufferedOutputStream(new FileOutputStream(FileDescriptor.out)),true)); System.out.println("im backing"); PrintWriter pw = new PrintWriter(new BufferedOutputStream(new FileOutputStream("hello.txt")),true); pw.println("打印流"); pw.println(true); pw.close(); &#125;&#125; 文件分割与合并RandomAccessFile 支持读取和写入随机访问文件 seek()设置文件的指针偏移 相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.mupa.io;import java.io.*;import java.util.ArrayList;import java.util.List;public class SplitFile &#123; private File src; private String destDir; private List&lt;String&gt; destPaths; private int blockSize; private int size; private long len; public SplitFile(String srcPath, String destDir, int blockSize) &#123; this.src = new File(srcPath); this.destDir = destDir; this.blockSize = blockSize; this.destPaths = new ArrayList&lt;String&gt;(); init(); &#125; private void init() &#123; this.len = this.src.length(); this.size = (int) Math.ceil(this.len*1.0/blockSize); for(int i=0;i&lt;size;i++)&#123; this.destPaths.add(this.destDir+"/"+i+"-"+this.src.getName()); &#125; &#125; private void split() throws IOException &#123; int beginPos = 0; int actualSize = (int)(blockSize&gt;len?len:blockSize); for(int i=0;i&lt;size;i++)&#123; beginPos = i*blockSize; if(i==size-1)&#123; actualSize = (int)len; &#125;else&#123; actualSize = blockSize; len -=actualSize; &#125; System.out.println("正在输出块"+i); splitDetail(i,beginPos,actualSize); &#125; &#125; private void splitDetail(int i, int beginPos, int actualSize) throws IOException &#123; RandomAccessFile raf = new RandomAccessFile(this.src,"r"); RandomAccessFile raf2 = new RandomAccessFile(this.destPaths.get(i),"rw"); raf.seek(beginPos); byte[] flush = new byte[1024]; int len = -1; while((len=raf.read(flush))!=-1)&#123; if(actualSize&gt;len)&#123; raf2.write(flush,0,len); actualSize-=len; &#125;else&#123; raf2.write(flush,0,actualSize); break; &#125; &#125; raf2.close(); raf.close(); &#125; public void merge(String destPath) throws IOException &#123; OutputStream os = new BufferedOutputStream(new FileOutputStream(destPath,true)); for(int i=0;i&lt;size;i++)&#123; InputStream is = new BufferedInputStream(new FileInputStream(destPaths.get(i))); byte[] flush = new byte[1024]; int len=-1; while((len=is.read(flush))!=-1)&#123; os.write(flush,0,len); &#125; os.flush(); is.close(); &#125; os.close(); &#125; public static void main(String[] args) throws IOException &#123; SplitFile sf = new SplitFile("src/me.png","src/dest",1024); sf.split(); sf.merge("aaa.png"); &#125;&#125; 文件合并SequenceInputStream 可以吧多个输入流合并到一起然后将文件合并 使用Vector容器，载入到SequenceInputStream 相关代码123456789101112131415161718public void merge(String destPath) throws IOException &#123; OutputStream os = new BufferedOutputStream(new FileOutputStream(destPath,true)); Vector&lt;InputStream&gt; vi = new Vector&lt;&gt;(); SequenceInputStream sis = null; for(int i=0;i&lt;size;i++)&#123; vi.add(new BufferedInputStream(new FileInputStream(destPaths.get(i)))); &#125; sis = new SequenceInputStream(vi.elements()); byte[] flush = new byte[1024]; int len=-1; while((len=sis.read(flush))!=-1)&#123; os.write(flush,0,len); &#125; os.flush(); sis.close(); os.close(); &#125; CommonsIOFileUtils读写相关： sizeof()统计文件大小 listFiles(地址，文件过滤，目录过滤)遍历文件 readFileToString(地址，编码)读取文件内容 readFileToByteArray(地址)读文件为字符数组 readLines(地址，编码)逐行读取 lineIterator(地址，编码)迭代器读取方法 write(地址，内容，编码) writeStringToFile(地址，内容，编码，追加) writeByteArrayToFile(地址，字符数组，追加) writeLines(地址，List，间隔符，追加) 拷贝相关： copyFile(源文件地址，目的文件地址)拷贝文件 copyFileToDir(源文件地址，目的目录地址)拷贝文件到目录 copyDirectoryToDirectory(源目录地址，目的目录地址)复制目录到目录 copyDirectory(源目录地址，目的目录地址)复制目录内的内容到目的目录 copyURLToFile(URL，文件地址)拷贝URL的内容——如果是文字可以用IOUtils.toString(URL，编码)]]></content>
      <categories>
        <category>program</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
</search>
